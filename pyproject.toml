[project]
name = "video-scene-splitter"
version = "0.2.0-dev"
description = "A video processing tool that automatically detects and splits videos at hard cuts using computer vision techniques with optional GPU acceleration"
readme = "README.md"
license = "MIT"
requires-python = ">=3.13"

# Core dependencies - GPU acceleration is optional and auto-detected at runtime
# GPU features gracefully fallback to CPU when unavailable
dependencies = [
    # Core dependencies (always required)
    # NumPy 2.x compatible with CuPy 13.6.0 (tested up to NumPy 2.3)
    "numpy>=2.0.0,<2.4",
    "opencv-python>=4.10.0",
]

[project.optional-dependencies]
# GPU acceleration with NVIDIA CUDA 13.x (requires CUDA 13.0+)
# Install with: uv sync --extra gpu (or pip install .[gpu])
# CuPy 13.6.0 supports: CUDA 11.2-13.0, Python 3.9-3.13, NumPy 1.22-2.3
gpu = [
    "cupy-cuda13x>=13.6.0",
]

# GPU acceleration with NVIDIA CUDA 12.x (for systems with CUDA 12.x)
# Install with: uv sync --extra gpu-cuda12 (or pip install .[gpu-cuda12])
gpu-cuda12 = [
    "cupy-cuda12x>=13.6.0",
]

# CPU-only installation (excludes optional GPU dependencies)
# Install with: uv sync --extra cpu-only (or pip install .[cpu-only])
cpu-only = [
    "numpy>=2.0.0,<2.4",
    "opencv-python>=4.10.0",
]

# Development dependencies
dev = [
    "ruff>=0.8.0",
    "pre-commit>=4.0.0",
    "poethepoet>=0.31.1",
    "pytest>=8.3.0",
    "pytest-cov>=6.0.0",
    "pytest-xdist>=3.6.0",
    "pytest-mock>=3.14.0",
]

# Development with GPU testing support (CUDA 13.x)
dev-gpu = [
    "video-scene-splitter[dev,gpu]",
]

# Development with GPU testing support (CUDA 12.x)
dev-gpu-cuda12 = [
    "video-scene-splitter[dev,gpu-cuda12]",
]

[tool.ruff]
# Set the maximum line length to 100 characters (matching project style guide)
line-length = 100
# Target Python 3.13 (latest version supported by CuPy for GPU acceleration)
target-version = "py313"
# Exclude common directories
exclude = [
    ".git",
    ".venv",
    "venv",
    "__pycache__",
    "*.pyc",
    ".pytest_cache",
    "build",
    "dist",
]

[tool.ruff.lint]
# Enable the following rule sets:
# E/W: pycodestyle errors and warnings
# F: Pyflakes
# I: isort (import sorting)
# N: pep8-naming
# UP: pyupgrade (modernize Python code)
# B: flake8-bugbear (find likely bugs)
# C4: flake8-comprehensions (better list/dict/set comprehensions)
# SIM: flake8-simplify (simplify code)
# RUF: Ruff-specific rules
select = ["E", "W", "F", "I", "N", "UP", "B", "C4", "SIM", "RUF"]
# Ignore specific rules if needed
ignore = []

[tool.ruff.lint.per-file-ignores]
# Allow unused imports in __init__.py files
"__init__.py" = ["F401"]

[tool.ruff.format]
# Use double quotes for strings (Black-compatible)
quote-style = "double"
# Use spaces for indentation
indent-style = "space"
# Respect magic trailing commas
skip-magic-trailing-comma = false
# Auto-detect line endings
line-ending = "auto"

[tool.ruff.lint.isort]
# Organize imports with known first-party modules
known-first-party = ["video_scene_splitter"]

[tool.poe.tasks]
# Development scripts for code quality and formatting
# These will remain in [tool.poe.tasks] even when CLI is implemented in [project.scripts]
lint = "ruff check ."
format = "ruff format ."
lint-fix = "ruff check --fix ."

# Testing scripts
test = "pytest"
test-verbose = "pytest -vv"
test-coverage = "pytest --cov=video_scene_splitter --cov-report=term-missing --cov-report=html"
test-watch = "pytest --watch"
test-parallel = "pytest -n auto"

# Application scripts
# Note: When implementing a proper CLI, add entry points to [project.scripts]
# and optionally keep these as convenience wrappers or remove them
start = "python main.py"

# Composite task to run both lint and format check
[tool.poe.tasks.check]
sequence = ["lint", "format --check ."]
help = "Run all code quality checks (lint + format check)"

# Composite task to run all checks including tests
[tool.poe.tasks.check-all]
sequence = ["lint", "format --check .", "test"]
help = "Run all code quality checks and tests"

# ============================================================================
# Pytest Configuration
# ============================================================================
# Configuration for the pytest test framework
# Run tests with: pytest or uv run poe test
# See CONTRIBUTING.md for detailed testing guidelines

[tool.pytest.ini_options]
# Minimum pytest version required
minversion = "8.3"

# Test Discovery Patterns
# Pytest will automatically discover and run tests matching these patterns
testpaths = ["tests"]                    # Directory containing test files
python_files = ["test_*.py", "*_test.py"] # Test file naming patterns
python_classes = ["Test*"]                # Test class naming pattern
python_functions = ["test_*"]             # Test function naming pattern

# Default Command-Line Options
# These options are applied automatically when running pytest
addopts = [
    "-ra",                    # Show summary of all test outcomes (passed, failed, skipped, etc.)
    "--strict-markers",       # Raise error on unknown markers (prevents typos in marker names)
    "--strict-config",        # Raise error on configuration issues
    "--showlocals",           # Show local variables in tracebacks for easier debugging
    "-v",                     # Verbose output showing individual test names
]

# Test Markers
# Use markers to categorize and selectively run tests
# Examples:
#   pytest -m unit              # Run only unit tests
#   pytest -m integration       # Run only integration tests
#   pytest -m "not slow"        # Skip slow tests
#   pytest -m "not gpu"         # Skip GPU tests (run on CPU-only systems)
markers = [
    "unit: Unit tests for individual functions and methods",
    "integration: Integration tests for complete workflows and component interaction",
    "slow: Tests that take significant time to run (e.g., processing large files)",
    "gpu: Tests requiring CUDA GPU (automatically skipped if GPU unavailable)",
]

# ============================================================================
# Coverage Configuration
# ============================================================================
# Configuration for pytest-cov coverage reporting
# Run with: pytest --cov=video_scene_splitter --cov-report=term-missing

[tool.coverage.run]
# Source code to measure coverage for
source = ["video_scene_splitter"]

# Files and directories to exclude from coverage measurement
omit = [
    "*/tests/*",              # Test files themselves
    "*/__pycache__/*",        # Python bytecode cache
    "*/venv/*",               # Virtual environment (venv)
    "*/.venv/*",              # Virtual environment (.venv)
]

[tool.coverage.report]
# Coverage report formatting options
precision = 2                 # Decimal places for coverage percentages (e.g., 99.42%)
show_missing = true           # Show line numbers of missing coverage
skip_covered = false          # Include fully covered files in report

# Lines to exclude from coverage measurement
# These patterns are typically for code that doesn't need testing
exclude_lines = [
    "pragma: no cover",                # Explicit coverage exclusion marker
    "def __repr__",                    # String representation methods
    "raise AssertionError",            # Assertion failures (defensive programming)
    "raise NotImplementedError",       # Abstract method placeholders
    "if __name__ == .__main__.:",      # Script entry points
    "if TYPE_CHECKING:",               # Type checking imports (runtime vs. static analysis)
]

